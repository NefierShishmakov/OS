first thread:
///////
lock(m)
state = READ_OK
signal(cond)
unlock(m)
///////


second thread:
//////
lock(m)
while(state != READ_OK)
    wait(cond, m)
state = READ_NOK;
unlock(m)
//////


Explanation how it works:
First case:
    Если первый поток первый захватывает мьютекс,
    он просто делает state = READ_OK,
    отправляет сигнал и делает unlock(m)

    Тем временем, второй поток захватывает мьютекс
    Видит что state == READ_OK, в цикл не заходит, тем самым
    игнорирует сигнал, делает state = READ_NOK
    и делает unlock(m)

Second case:
    Если второй поток захватывает мьютекс,
    Он заходит в цикл, разблокирует мьютекс и блокируется на условной переменной
    Тем временем первый поток захватывает мьютекс,
    делает state = READ_OK
    и отправляет сигнал
    Второй поток получает сигнал, блокирует мьютекс, ждёт пока первый поток сделает unlock(m),
    и wait(cond, m) завершается, делает state = READ_NOK
    и unlock(m)
