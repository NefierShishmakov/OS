Почему нельзя делать в качестве параметра pthread_exit() передавать адрес переменной, выделенной на стеке.
Всё дело в реализации функции pthread_join(void **retval)

Внутри pthread_join есть такие строчки:
if (thread_result != NULL) {
    *thread_result = pd_result;
}

_nptl_free_tcb(pd); - эта функция для освобождения стэка потока

Т.е. если мы в потоке, который сделал pthread_join, попытаемся разименовать указатель, то мы получим мусор, так как 
стэк нити, на которую мы сделали pthread_join был уничтожен, в том числе будут уничтожен дескриптор нити и thread local data.

Но при этом если мы сделали просто pthread_exit(NULL), и нить является JOINABLE, то все ресурсы связанные с потоком, такие как
стэк, thread local data, дескриптор нити будут ещё живы. В том числе, когда поток завершается, общие ресурсы процесса, такие как
mutexes, condition variables, semaphores and file descriptors не освобождены.

И какая неприятная ситуация связи с этим может возникнуть.
Представим ситуацию, что один поток захватил мьютекс, начал данные обрабатывать, не успел их обработать и неожиданно завершился.
Тогда все остальные потоки, которые дошли до строчки, pthread_mutex_lock, просто будут навсегда заблокированы, т.е. произойдёт
deadlock.
