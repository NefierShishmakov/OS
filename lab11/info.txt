int pthread_mutexattr_destroy(pthread_mutexattr_t *attr):
    Эта функция должна уничтожить объект аттрибутов мьютекса. Объект становится, в результате, неинициализированным.
    Реализация может привести к тому, что эта функция установит для объекта, на который ссылается attr, недопустимое
    значение.
    Уничтоженный объект атрибутов attr можно повторно инициализировать с помощью pthread_mutexattr_init();

    Возвращаемое значение:
        В случае успешного завершения функция должна вернуть 0, в противном случае должен быть возвращен номер ошибки,
        указывающий на ошибку.

    Ошибки: нет

int pthread_mutexattr_init(pthread_mutexattr_t *attr):
    Функция pthread_mutexattr_init() должна инициализировать attr объекта атрибутов мьютекса значением по умолчанию
    для всех атрибутов, определенных реализацией.

    Атрибуты мьютекса:
        type - PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_ERRORCHECK PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_DEFAULT
        И если нам нужен мьютекс с атрибутами, у которых значения по умолчанию, то type - PTHREAD_MUTEX_DEFAULT
        Все эти атрибуты описаны ниже в описании функции pthread_mutexattr_settype

        robustness - PTHREAD_MUTEX_STALLED, PTHREAD_MUTEX_ROBUST

        PTHREAD_MUTEX_STALLED(значение по умолчанию) -
            Никаких специальных действий не предпринимается, если владелец мьютекса завершается,
            удерживая блокировку мьютекса.
            Это может привести к взаимоблокировкам, если ни один другой поток не сможет разблокировать мьютекс.
            Это значение по умолчанию.

        PTHREAD_MUTEX_ROBUST - Если мьютекс инициализируется с атрибутом PTHREAD_MUTEX_ROBUST,
        а его владелец умирает, не разблокировав его, любые будущие попытки вызвать pthread_mutex_lock(3)
        для этого мьютекса будут успешными и вернут EOWNERDEAD, чтобы указать,
        что первоначальный владелец больше не существует и мьютекс находится в несогласованном состоянии.
        Обычно после возврата EOWNERDEAD следующий владелец должен вызвать pthread_mutex_consistent(3)
        для полученного мьютекса, чтобы снова сделать его согласованным,
        прежде чем использовать его дальше.
        Если следующий владелец разблокирует мьютекс с помощью pthread_mutex_unlock(3) до того,
        как сделает его согласованным, мьютекс будет навсегда непригоден для использования,
        и любые последующие попытки заблокировать его с помощью pthread_mutex_lock(3) завершатся с
        ошибкой ENOTRECOVERABLE.
        Единственная разрешенная операция с таким мьютексом — это pthread_mutex_destroy(3).
        Если следующий владелец завершает работу до вызова pthread_mutex_consistent(3),
        дальнейшие операции pthread_mutex_lock(3) с этим мьютексом все равно будут возвращать EOWNERDEAD.


        process-shared attribute - PTHREAD_PROCESS_SHARED PTHREAD_PROCESS_PRIVATE

        PTHREAD_PROCESS_PRIVATE(значение по умолчанию) - мьютекс может быть захвачен и освобожден, в рамках
        потоков одного процесса.

        PTHREAD_PROCESS_SHARED - Мьютексы, созданные с помощью этого объекта атрибутов,
        могут совместно использоваться любыми потоками, имеющими доступ к памяти, содержащей объект,
        включая потоки в разных процессах.

        protocol - как поток ведет себя с точки зрения приоритета, когда поток с более высоким приоритетом хочет мьютекс

        priority ceiling - Этот атрибут содержит максимальный приоритет инициализированных мьютексов.
        Значения prioceiling находятся в пределах максимального диапазона приоритетов, определенных SCHED_FIFO.
        Значение по умолчанию 1

    После того как объект атрибутов мьютекса был использован для инициализации одного или нескольких мьютексов,
    любая функция, влияющая на объект атрибутов (включая уничтожение), не должна воздействовать ни на какие ранее
    инициализированные мьютексы.

    Возвращаемое значение:
        В случае успешного завершения функция должна вернуть 0, в противном случае должен быть возвращен номер ошибки,
        указывающий на ошибку.

    Ошибки:
        ENOMEM - Недостаточно памяти для инициализации объекта атрибутов мьютекса.

int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type):
    Эта функция должна устанавливать аттрибут mutex type.
    Значение атрибута типа по умолчанию — PTHREAD_MUTEX_DEFAULT.

    Тип мьютекса содержится в атрибуте type атрибутов мьютекса.

    К допустимым типам мьютексов относятся:
        PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_ERRORCHECK
        PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_DEFAULT

        PTHREAD_MUTEX_NORMAL:
            Этот тип мьютекса не обнаруживает взаимоблокировку.
            Поток, пытающийся повторно заблокировать этот мьютекс без его предварительного разблокирования, словит deadlock.
            Т.е. , если один поток захватит мьютекс и его не освободит, а другой поток тоже захватит мьютекс то произойдёт
            deadlock.

            Попытка разблокировать мьютекс, заблокированный другим потоком, приводит к неопределенному поведению.
            Попытка разблокировать разблокированный мьютекс приводит к неопределенному поведению.

        PTHREAD_MUTEX_ERRORCHECK:
            Этот тип мьютекса обеспечивает проверку ошибок.
            Поток, пытающийся повторно заблокировать этот мьютекс без его предварительного разблокирования, вернется с ошибкой.
            Поток, пытающийся разблокировать мьютекс, заблокированный другим потоком, вернется с ошибкой.
            Поток, пытающийся разблокировать разблокированный мьютекс, вернется с ошибкой.

            Что значит, поток вернётся с ошибкой, это означает, что если мы сделаем что-то что описано выше,
            и если мы сохраним возвращаемое значение pthread_mutex_lock или pthread_mutex_unlock в переменную,
            и вызовим функцию perror, то perror нам скажет, что мы сделали не так, и программа не зависнет.

        PTHREAD_MUTEX_RECURSIVE:
            Позволяет одному и тому же pthread, блокировать несколько раз мьютекс, без предварительной разблокировки
            и не произойдёт взаимоблокировки и pthread_mutex_lock не вернёт ненулевое значение.
            Т.е. мы можем в одном и том же потоке делать несколько раз pthread_mutex_lock, но для того чтобы другие
            потоки могли захватить этот мьютекс, мы должны сделать pthread_mutex_unlock столько раз, сколько сделали
            pthread_mutex_lock, в том потоке, в котором мы делали pthread_mutex_lock

            Когда мы используем рекурсивный тип мьютекса, мьютекс должен поддерживать концепцию счетчика блокировок.
            Когда поток успешно захватывает мьютекс в первый раз, счетчик блокировок должен быть установлен в единицу.
            Каждый раз, когда поток повторно блокирует этот мьютекс, счетчик блокировок должен увеличиваться на единицу.
            Каждый раз, когда поток разблокирует мьютекс, счетчик блокировок должен уменьшаться на единицу.
            Когда счетчик блокировок достигает нуля, мьютекс становится доступным для захвата другими потоками.

        PTHREAD_MUTEX_DEFAULT - дефолтное значение мьютекса:
            Если тип мьютекса PTHREAD_MUTEX_DEFAULT, поведение pthread_mutex_lock() может
            соответствовать одному из трех
            других стандартных типов мьютекса, как описано в таблице выше.
            Если он не соответствует ни одному из этих трех, поведение не определено для отмеченных случаев.

    Тип мьютекса влияет на поведение вызовов, блокирующих и разблокирующих мьютекс.

    Возвращаемое значение:
        В случае успеха функция pthread_mutexattr_settype() должна возвращать ноль;
        в противном случае должен быть возвращен номер ошибки, указывающий на ошибку.

    Ошибки:
        EINVAL - недопустимый тип значения.

int pthread_mutex_destroy(pthread_mutex_t *mutex):
    Функция pthread_mutex_destroy() должна уничтожить объект мьютекса, на который ссылается мьютекс;
    объект мьютекса фактически становится неинициализированным.
    Реализация может привести к тому, что pthread_mutex_destroy() установит для объекта, на который ссылается мьютекс,
    недопустимое значение.

    Уничтоженный объект мьютекса можно повторно инициализировать с помощью функции pthread_mutex_init();
    результаты других ссылок на объект после его уничтожения не определены.

    Должно быть безопасно уничтожить разблокированный инициализированный мьютекс.
    Попытка уничтожить заблокированный мьютекс или мьютекс, который пытается блокировать другой поток,
    приводит к неопределенному поведению.

    Возвращаемое значение:
        Возвращает 0 в случае успеха, в ином случае возвращает код ошибки.

int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr):
    Функция pthread_mutex_init() должна инициализировать мьютекс, на который ссылается мьютекс, с атрибутами,
    указанными в атрибуте attr. Если attr имеет значение NULL, используются атрибуты мьютекса по умолчанию;
    После успешной инициализации состояние мьютекса становится инициализированным и разблокированным.

    В тех случаях, когда атрибуты мьютекса по умолчанию являются подходящими,
    для инициализации мьютексов можно использовать макрос PTHREAD_MUTEX_INITIALIZER.
    Эффект должен быть эквивалентен динамической инициализации вызовом pthread_mutex_init() с параметром attr,
    указанным как NULL, за исключением того, что проверки ошибок не выполняются.

    Возвращаемое значение:
            Возвращает 0 в случае успеха, в ином случае возвращает код ошибки.

    Ошибки:
        EAGAIN - системе не хватало необходимых ресурсов для инициализации другого мьютекса.
        ENOMEM - Недостаточно памяти для инициализации мьютекса
        EPERM - Вызывающий не имеет права выполнять операцию

int pthread_mutex_lock(pthread_mutex_t *mutex):
    Объект мьютекса, на который ссылается мьютекс, должен быть заблокирован вызовом pthread_mutex_lock(),
    Если мьютекс уже заблокирован другим потоком, вызывающий поток должен заблокироваться до тех пор,
    пока мьютекс не станет доступным.

    Если поток попытается заблокировать мьютекс, без его предварительной разблокировки или поток попытается
    разблокировать мьютекс, если он его не захватил, результат этих действий зависит от того, какого типа
    наш мьютекс.

    Если мьютекс является надежным (robust) мьютексом и процесс, содержащий поток-владелец,
    завершился, удерживая блокировку мьютекса, вызов pthread_mutex_lock() должен вернуть значение ошибки [EOWNERDEAD].
    Если мьютекс является надежным мьютексом, а поток-владелец завершился, удерживая блокировку мьютекса,
    вызов pthread_mutex_lock() может вернуть значение ошибки [EOWNERDEAD], даже если процесс,
    в котором находится поток-владелец, не завершился.

    Возвращаемое значение:
        В случае успеха 0, иначе код ошибки.

    Ошибки:
        EAGAIN - Мьютекс не может быть получен, так как превышено максимальное количество рекурсивных блокировок
        для мьютекса.

        EINVAL - Мьютекс был создан с атрибутом протокола, имеющим значение PTHREAD_PRIO_PROTECT,
        и приоритет вызывающего потока выше, чем текущий приоритета мьютекса.

        ENOTRECOVERABLE - Состояние, защищенное мьютексом, не может быть восстановлено.

        EOWNERDEAD - Если мьютекс является надежным (robust) мьютексом и процесс, содержащий поток-владелец,
                         завершился, удерживая блокировку мьютекса, вызов pthread_mutex_lock() должен вернуть значение ошибки [EOWNERDEAD].
                         Если мьютекс является надежным мьютексом, а поток-владелец завершился, удерживая блокировку мьютекса,
                         вызов pthread_mutex_lock() может вернуть значение ошибки [EOWNERDEAD], даже если процесс,
                         в котором находится поток-владелец, не завершился.

        EPERM - Тип мьютекса — PTHREAD_MUTEX_ERRORCHECK или PTHREAD_MUTEX_RECURSIVE,
        или мьютекс является надежным мьютексом, и текущий поток не владеет мьютексом

        EDEADLK - Обнаружено состояние взаимоблокировки.

int pthread_mutex_unlock(pthread_mutex_t *mutex):
    Функция pthread_mutex_unlock() должна освободить объект мьютекса, на который ссылается мьютекс.
    Способ освобождения мьютекса зависит от атрибута типа мьютекса.

    Возвращаемое значение и ошибки точно такие же как у pthread_mutex_lock
    

